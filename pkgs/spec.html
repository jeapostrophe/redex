<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text-html; charset=utf-8" /><title>Racket Packages</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default" /><link rel="stylesheet" type="text/css" href="racket.css" title="default" /><link rel="stylesheet" type="text/css" href="scribble-style.css" title="default" /><script type="text/javascript" src="scribble-common.js"></script></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist" style="margin-bottom: 1em;"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" pltdoc="x">Racket Packages</a></td></tr></table></div><div class="tocviewsublistonly" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="#(part._.Problems_with_current_regime)" class="tocviewlink" pltdoc="x">Problems with current regime</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="#(part._.Good_things_about_the_current_regime)" class="tocviewlink" pltdoc="x">Good things about the current regime</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="#(part._.Going_forward)" class="tocviewlink" pltdoc="x">Going forward</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="#(part._.Packages)" class="tocviewlink" pltdoc="x">Packages</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="#(part._.Glue_between_installation_and_distribution)" class="tocviewlink" pltdoc="x">Glue between installation and distribution</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="#(part._.Package_.Distribution)" class="tocviewlink" pltdoc="x">Package Distribution</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="#(part._.Final_.Thoughts)" class="tocviewlink" pltdoc="x">Final Thoughts</a></td></tr></table></div></div></div><div class="tocsub"><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#(part._.Problems_with_current_regime)" class="tocsubseclink" pltdoc="x">Problems with current regime</a></td></tr><tr><td><span class="tocsublinknumber">1.1<tt>&nbsp;</tt></span><a href="#(part._.P.Lane.T_packages_are_second-class)" class="tocsubseclink" pltdoc="x">PLane<span class="mywbr"> </span>T packages are second-<wbr></wbr>class</a></td></tr><tr><td><span class="tocsublinknumber">1.2<tt>&nbsp;</tt></span><a href="#(part._.P.Lane.T_packages_are_hard_to_upgrade)" class="tocsubseclink" pltdoc="x">PLane<span class="mywbr"> </span>T packages are hard to upgrade</a></td></tr><tr><td><span class="tocsublinknumber">1.3<tt>&nbsp;</tt></span><a href="#(part._.P.Lane.T_code_is_not_easy_to_improve)" class="tocsubseclink" pltdoc="x">PLane<span class="mywbr"> </span>T code is not easy to improve</a></td></tr><tr><td><span class="tocsublinknumber">1.4<tt>&nbsp;</tt></span><a href="#(part._.P.Lane.T_packages_are_hard_to_discover_or_trust)" class="tocsubseclink" pltdoc="x">PLane<span class="mywbr"> </span>T packages are hard to discover or trust</a></td></tr><tr><td><span class="tocsublinknumber">1.5<tt>&nbsp;</tt></span><a href="#(part._.P.Lane.T_is_too_centralized)" class="tocsubseclink" pltdoc="x">PLane<span class="mywbr"> </span>T is too centralized</a></td></tr><tr><td><span class="tocsublinknumber">1.6<tt>&nbsp;</tt></span><a href="#(part._.The_core_is_too_big)" class="tocsubseclink" pltdoc="x">The core is too big</a></td></tr><tr><td><span class="tocsublinknumber">1.7<tt>&nbsp;</tt></span><a href="#(part._.Pieces_of_the_core_cannot_be_held-back)" class="tocsubseclink" pltdoc="x">Pieces of the core cannot be held-<wbr></wbr>back</a></td></tr><tr><td><span class="tocsublinknumber">1.8<tt>&nbsp;</tt></span><a href="#(part._.There_is_no_migration_from_the_core_to_.P.Lane.T_or_vice_versa)" class="tocsubseclink" pltdoc="x">There is no migration from the core to PLane<span class="mywbr"> </span>T or vice versa</a></td></tr><tr><td><span class="tocsublinknumber">1.9<tt>&nbsp;</tt></span><a href="#(part._.Installations_are_expensive)" class="tocsubseclink" pltdoc="x">Installations are expensive</a></td></tr><tr><td><span class="tocsublinknumber">1.10<tt>&nbsp;</tt></span><a href="#(part._.Poor_security_defaults)" class="tocsubseclink" pltdoc="x">Poor security defaults</a></td></tr><tr><td><span class="tocsublinknumber">1.11<tt>&nbsp;</tt></span><a href="#(part._.Nothing_is_ever_private)" class="tocsubseclink" pltdoc="x">Nothing is ever private</a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#(part._.Good_things_about_the_current_regime)" class="tocsubseclink" pltdoc="x">Good things about the current regime</a></td></tr><tr><td><span class="tocsublinknumber">2.1<tt>&nbsp;</tt></span><a href="#(part._.It_just_works)" class="tocsubseclink" pltdoc="x">It just works</a></td></tr><tr><td><span class="tocsublinknumber">2.2<tt>&nbsp;</tt></span><a href="#(part._.Free_hosting_of_source_in_central_place)" class="tocsubseclink" pltdoc="x">Free hosting of source in central place</a></td></tr><tr><td><span class="tocsublinknumber">2.3<tt>&nbsp;</tt></span><a href="#(part._.Package_preview_is_very_easy)" class="tocsubseclink" pltdoc="x">Package preview is very easy</a></td></tr><tr><td><span class="tocsublinknumber">3<tt>&nbsp;</tt></span><a href="#(part._.Going_forward)" class="tocsubseclink" pltdoc="x">Going forward</a></td></tr><tr><td><span class="tocsublinknumber">4<tt>&nbsp;</tt></span><a href="#(part._.Packages)" class="tocsubseclink" pltdoc="x">Packages</a></td></tr><tr><td><span class="tocsublinknumber">4.1<tt>&nbsp;</tt></span><a href="#(part._.Vocabulary)" class="tocsubseclink" pltdoc="x">Vocabulary</a></td></tr><tr><td><span class="tocsublinknumber">4.2<tt>&nbsp;</tt></span><a href="#(part._.Principles)" class="tocsubseclink" pltdoc="x">Principles</a></td></tr><tr><td><span class="tocsublinknumber">4.3<tt>&nbsp;</tt></span><a href="#(part._.Plausible_.Implementation)" class="tocsubseclink" pltdoc="x">Plausible Implementation</a></td></tr><tr><td><span class="tocsublinknumber">4.4<tt>&nbsp;</tt></span><a href="#(part._.Discussion)" class="tocsubseclink" pltdoc="x">Discussion</a></td></tr><tr><td><span class="tocsublinknumber">5<tt>&nbsp;</tt></span><a href="#(part._.Glue_between_installation_and_distribution)" class="tocsubseclink" pltdoc="x">Glue between installation and distribution</a></td></tr><tr><td><span class="tocsublinknumber">6<tt>&nbsp;</tt></span><a href="#(part._.Package_.Distribution)" class="tocsubseclink" pltdoc="x">Package Distribution</a></td></tr><tr><td><span class="tocsublinknumber">7<tt>&nbsp;</tt></span><a href="#(part._.Final_.Thoughts)" class="tocsubseclink" pltdoc="x">Final Thoughts</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><h2><a name="(part._.Racket_.Packages)"></a>Racket Packages</h2><div class="SAuthorListBox"><span class="SAuthorList"><p class="author">Jay McCarthy</p></span></div><p>The state of packaging in Racket is not where it must be.</p><table cellspacing="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#(part._.Problems_with_current_regime)" class="toptoclink" pltdoc="x">1<span class="hspace">&nbsp;</span>Problems with current regime</a></p></td></tr><tr><td><p><span class="hspace"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#(part._.Good_things_about_the_current_regime)" class="toptoclink" pltdoc="x">2<span class="hspace">&nbsp;</span>Good things about the current regime</a></p></td></tr><tr><td><p><span class="hspace"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#(part._.Going_forward)" class="toptoclink" pltdoc="x">3<span class="hspace">&nbsp;</span>Going forward</a></p></td></tr><tr><td><p><span class="hspace"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#(part._.Packages)" class="toptoclink" pltdoc="x">4<span class="hspace">&nbsp;</span>Packages</a></p></td></tr><tr><td><p><span class="hspace"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#(part._.Glue_between_installation_and_distribution)" class="toptoclink" pltdoc="x">5<span class="hspace">&nbsp;</span>Glue between installation and distribution</a></p></td></tr><tr><td><p><span class="hspace"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#(part._.Package_.Distribution)" class="toptoclink" pltdoc="x">6<span class="hspace">&nbsp;</span>Package Distribution</a></p></td></tr><tr><td><p><span class="hspace"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><a href="#(part._.Final_.Thoughts)" class="toptoclink" pltdoc="x">7<span class="hspace">&nbsp;</span>Final Thoughts</a></p></td></tr></table><h3>1<tt>&nbsp;</tt><a name="(part._.Problems_with_current_regime)"></a>Problems with current regime</h3><p>Before presenting the new proposal, I review what I see the problems are with what we have now.
I think of these as "test cases" on the new package system. If these are not adequate, then
the new package system is unlikely to be worth it.</p><h4>1.1<tt>&nbsp;</tt><a name="(part._.P.Lane.T_packages_are_second-class)"></a>PLaneT packages are second-class</h4><p>First, they cannot come with a distribution: it is not possible for Racket developers to provide installers for a Racket instance that includes PLaneT packages. This affects core developers and educators in particular: This affects core developers by encouraging more and more functionality in the core. (For example, Redex was once separate, but was moved in for convenience.) This affects educators because it complicates their installation instructions and puts pressure to move textbook support into the core (c.f. PLAI, Picturing Programs, HTDP, DMDA, etc.)</p><p>Second, they are required in a very different way: <span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">require</span></span></span><span class="stt"> </span><span class="RktSym">xml</span><span class="RktPn">)</span> vs
<span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">require</span></span></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">planet</span></span></span><span class="stt"> </span><span class="RktSym">jay-mccarthy:1:1/xml</span><span class="RktPn">)</span><span class="RktPn">)</span>. A module that uses a PLaneT package is not insulated from the usage of PLaneT. This makes it hard to migrate things to and from PLaneT. It places distribution details throughout the code of a collection, rather than in a central location.</p><p>Third, their documentation is not searchable unless it is installable. Our online documentation system is not useful for exploring PLaneT libraries. Additionally, if PLaneT packages wish to cross-reference, that causes an installation, which discourages useful mentions of other packages.</p><h4>1.2<tt>&nbsp;</tt><a name="(part._.P.Lane.T_packages_are_hard_to_upgrade)"></a>PLaneT packages are hard to upgrade</h4><p>Packages are hard to upgrade because of the linking rules and the internal linking.</p><p>The semantics of PLaneT linking is confusing to many users and emphasizes stability as the default
rather than the exception. (If a module requires a package without a version number, it gets the most recent major and minor at the time it is compiled. However, if the local cache contains any version, that version is assumed to be the right version without recourse to the server. If a major version is specified, then the same process happens, but restricted to that major version&#8212;<wbr></wbr>which may causes a server pull, even if the cache contains a version of the package. If a minor version is specified, then a version newer than that must be used; this options only exists to refuse to use a cache version if it is too old. If a minor version is specified with =, then that version is used. Once a module is linked, according to the previous algorithm, it stays linked to that forever, until the local cache is cleaned and it is recompiled.) It is unfortunate that there is no interface in the command-line tool to clear the cache.</p><p>PLaneT uses internal linking (meaning that modules specify which PLaneT package at what version, as mentioned above) rather than external linking (where a module would specify that it needs "xml" and it would be part of a "project" that specifies that the "xml" module is provided by such and such a package.)</p><h4>1.3<tt>&nbsp;</tt><a name="(part._.P.Lane.T_code_is_not_easy_to_improve)"></a>PLaneT code is not easy to improve</h4><p>Although all PLaneT packages are de facto open source, it is very difficult to find the code that implements a PLaneT package on your system so you can improve or test it because of the deep and exotic directory structure. Supposing you did that, the PLaneT Web app does not provide a good way of communicating with the author of a package and tracking such things.</p><h4>1.4<tt>&nbsp;</tt><a name="(part._.P.Lane.T_packages_are_hard_to_discover_or_trust)"></a>PLaneT packages are hard to discover or trust</h4><p>When someone installs a fresh Racket installation, there is no indication that PLaneT even exists from the installer or from inside of DrRacket, etc. Even if someone discovers the site, it is very difficult to figure out what packages are worth investigating to see what they do and/or gaining trust in them. The amount of duplication on the Web page and the shallow hierarchy make it even more difficult to even discover what options are available.</p><h4>1.5<tt>&nbsp;</tt><a name="(part._.P.Lane.T_is_too_centralized)"></a>PLaneT is too centralized</h4><p>It is not easy to run PLaneT mirrors, private PLaneT servers, or collaborate/distribute with others using Racket without going through the centralized PLaneT server. This is especially problematic given the de facto open source of the centralized PLaneT server.</p><h4>1.6<tt>&nbsp;</tt><a name="(part._.The_core_is_too_big)"></a>The core is too big</h4><p>The core distribution is very large from the perspective of pure size and from the perspective of understandability and scope. The collects tree is over 200MB compiled. It contains half a dozen text book support library most people will not use. It is difficult to separate out the GUI correctly (as evidenced by the periodic dist-specs errors.) It contains barely supported collections (Algol 60, FrTime, MysterX, etc.)</p><h4>1.7<tt>&nbsp;</tt><a name="(part._.Pieces_of_the_core_cannot_be_held-back)"></a>Pieces of the core cannot be held-back</h4><p>Since the core is so big, many users would like to upgrade one piece, while leaving others constant. For example, a common request is to be able to keep an old version of the Web server, while upgrading the core Racket VM. There&rsquo;s no principled reason why this could not be done, because they are mostly separate and changes to the core rarely require immediate changes to the Web server, due to Matthew&rsquo;s great ability to maintain backwards compatibility. However, it is simply not an option to do this. The prospect of manually fusing collects trees is an unreasonable burden on programmers. Such a decomposition and independent upgrades would have been very useful, for example, in testing GR2.</p><h4>1.8<tt>&nbsp;</tt><a name="(part._.There_is_no_migration_from_the_core_to_.P.Lane.T_or_vice_versa)"></a>There is no migration from the core to PLaneT or vice versa</h4><p>This issue is briefly mentioned above, but given the difficulty of upgrading and the second-class-ness of PLaneT, we do not observe much movement between the core and PLaneT. It is too difficult to pull things out of the core and start distributing them on PLaneT because of the disadvantages of PLaneT. Additionally, if we want to move things into the core, to give them more visibility (itself a symptom of another problem), the PLaneT version has been maintained anyways. (Just ask me for PLAI, Carl for scheme.plt, etc.)</p><h4>1.9<tt>&nbsp;</tt><a name="(part._.Installations_are_expensive)"></a>Installations are expensive</h4><p>When a PLaneT package is installed, the compilation process is very expensive, especially when documentation building and re-indexing is counted. The PLaneT server (or packager) could conceivably provide already compiled versions of all these things for use by the end user.</p><h4>1.10<tt>&nbsp;</tt><a name="(part._.Poor_security_defaults)"></a>Poor security defaults</h4><p>The security defaults for PLaneT are very poor. For example, there is no verification that the right file came through; there is no check that the real PLaneT server was reached; the program is compiled without a sandbox (and since macros are infinitely powerful, compilation can mean compromise); a module can spawn PLaneT installations in sub-modules far away; etc.</p><h4>1.11<tt>&nbsp;</tt><a name="(part._.Nothing_is_ever_private)"></a>Nothing is ever private</h4><p>In Racket we have a convention of naming subdirectories of packages <span class="stt">"private"</span> but this does not actually prevent anything outside the package from in fact using these modules.</p><h3>2<tt>&nbsp;</tt><a name="(part._.Good_things_about_the_current_regime)"></a>Good things about the current regime</h3><p>Nevertheless, there are still some good things about PLaneT that we should maintain.</p><h4>2.1<tt>&nbsp;</tt><a name="(part._.It_just_works)"></a>It just works</h4><p>Modules are totally self-contained in their dependencies and packages automatically install. Contrast this to Perl where may have to iterate to a fixed-point attempting to run a script to discover its dependencies and install them as you go. In effect, there is zero system administration of the packages installed on a system.</p><h4>2.2<tt>&nbsp;</tt><a name="(part._.Free_hosting_of_source_in_central_place)"></a>Free hosting of source in central place</h4><p>It is good that we provide a free host to serve and learn about packages.</p><h4>2.3<tt>&nbsp;</tt><a name="(part._.Package_preview_is_very_easy)"></a>Package preview is very easy</h4><p>It is good that the PLaneT site provides easy access to all versions of a package with their documentation and source readily apparent.</p><h3>3<tt>&nbsp;</tt><a name="(part._.Going_forward)"></a>Going forward</h3><p>With these issues in mind, we&rsquo;d like to improve the situation. As a first step, I think it is important to distinguish between a packaging system and a package distribution and discovery system.</p><p>As it stands, we have a packaging system (<span class="stt">".plt"</span> files) with many complicated features that aren&rsquo;t really used (as far as I know) and an integrated packaging and package distribution system (PLaneT) that sits atop <span class="stt">".plt"</span>s, but reimplements some features.</p><p>The perspective I&rsquo;d like to take in improving packages in Racket is to start from a strict separation of packages and package distribution, then expand the capablities of our base packages, then build a more liberal and modern package distribution system.</p><h3>4<tt>&nbsp;</tt><a name="(part._.Packages)"></a>Packages</h3><p>In this section I talk about some of the properties of the packaging system at high-level then try to specify some low-level possible implementations.</p><h4>4.1<tt>&nbsp;</tt><a name="(part._.Vocabulary)"></a>Vocabulary</h4><p>A <a name="(tech._module)"></a><span style="font-style: italic">module</span> is the standard Racket module: a single file with dependencies and phased exports. For example, <span class="stt">"web-server/web-server.rkt"</span> is a module.</p><p>A <a name="(tech._collection)"></a><span style="font-style: italic">collection</span> is a tree of <a href="#(tech._module)" class="techoutside" pltdoc="x"><span class="techinside">module</span></a>s and associated data. For example, <span class="stt">"web-server"</span> is a collection of many modules and a few data files.</p><p>A <a name="(tech._package)"></a><span style="font-style: italic">package</span> is a set of <a href="#(tech._collection)" class="techoutside" pltdoc="x"><span class="techinside">collection</span></a>s and metadata. For example, the Web Server package might contain the <span class="stt">"web-server"</span> and <span class="stt">"tests/web-server"</span> collections; the DrRacket package might contain the <span class="stt">"drracket"</span> and <span class="stt">"drscheme"</span> collections (one provides backward compatiblity, of course.)</p><p>Package metadata includes at least an identifier, a natural number version, <a href="#(tech._package)" class="techoutside" pltdoc="x"><span class="techinside">package</span></a> dependencies, and <a href="#(tech._module)" class="techoutside" pltdoc="x"><span class="techinside">module</span></a> protection information. For example, the Web Server package may be identified by <span class="stt">"racket-web-server"</span>, at version 30, depend on the XML package version 49 or higher, and mark <span class="stt">"web-server/private"</span> as private.</p><p>An <a name="(tech._installation)"></a><span style="font-style: italic">installation</span> is a set of <a href="#(tech._package)" class="techoutside" pltdoc="x"><span class="techinside">package</span></a>s such that each pairing of an identifier and a particular version appears at most once. For example, the Web Server version 30 may not be in an installation twice. This does <span style="font-style: italic">not</span> preclude packages installed at different versions (Web Server version 30 and 31) or packages with common modules (both the Xexpr and the SXML package providing a public <span class="stt">"xml"</span> module.)</p><h4>4.2<tt>&nbsp;</tt><a name="(part._.Principles)"></a>Principles</h4><p>Modules should not need to reference anything about the package they are apart of or that they depend on. This information will derived from their location on the filesystem, similiar to our current collections.</p><p>Installing a new version of package (version 40 to 41) will affect all dependents of that package, by default.</p><p>Package dependencies may be "frozen" at their current versions to ensure that no future installation operation will affect them.</p><p>Backwards incompatible changes of a package will require a new package identifer. (Similar to libgtk and libgtk2.)</p><p>Module protection information is respected.</p><p>Packageless modules should have an easy to determine set of modules available to them from the set of installed packages preferring newer versions.</p><p>Locating an installed module should be easy and in most cases, obvious.</p><p>Uninstalling packages should be possible.</p><h4>4.3<tt>&nbsp;</tt><a name="(part._.Plausible_.Implementation)"></a>Plausible Implementation</h4><p>(These details are much less important than what appears above. At the least they are an attempt to show that the above is feasible with minimal changes to the existing Racket infrastructure.)</p><p>An installation could be divided into <span class="RktVar">n</span> heaps where <span class="RktVar">n</span> is at least <span class="RktVal">2</span> for a user and system heap. (Other heaps could serve a group (i.e. class) specific heaps.)</p><p>Each heap would contain information about installed packages&#8212;<wbr></wbr>such as why they were installed (for something like <span class="stt">apt-get autoremove</span>) and whether their dependencies are frozen&#8212;<wbr></wbr>in a heap level database: <span class="stt">"&lt;heap&gt;/install.rktd"</span>.</p><p>Packages would be simple archives (as opposed to our homegrown <span class="stt">".plt"</span>s) containing a metadata file (<span class="stt">"info.rkt"</span>) and collection directories.</p><p>The package heaps would be structured as <span class="stt">"&lt;heap&gt;/&lt;package-id&gt;/&lt;version&gt;/&lt;collect&gt;"</span> where the contents of the collections is identical to the package source.</p><p><div class="SIntrapara">Each package&rsquo;s installation (<span class="stt">"&lt;heap&gt;/&lt;package-id&gt;/&lt;version&gt;"</span>) would contain a linking directory (<span class="stt">".links"</span>) with shadow modules for every module visible to them. For example,
<span class="stt">"system/web-server/30/.links/xml/main.rkt"</span> would roughly be:
</div><div class="SIntrapara"><table cellspacing="0" class="RktBlk"><tr><td><span class="hspace">&nbsp;&nbsp;</span><font class="badlink"><span class="RktModLink"><span class="RktMod">#lang</span></span></font><span class="hspace">&nbsp;</span><font class="badlink"><span class="RktModLink"><span class="RktSym">racket/shadow</span></span></font></td></tr><tr><td><span class="RktPlain"><span class="hspace">&nbsp;&nbsp;</span></span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">require</span></span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">real</span><span class="hspace">&nbsp;</span><span class="RktSym">system/xml/49/xml/main</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktPlain"><span class="hspace">&nbsp;&nbsp;</span></span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">provide</span></span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">all-from-out</span></span></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">real</span><span class="hspace">&nbsp;</span><span class="RktSym">system/xml/49/xml/main</span><span class="RktPn">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></div><div class="SIntrapara">Modules not written in the restricted shadow language would not see the "heap level" of modules and could not use the "real" modules, instead <span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">require</span></span></span><span class="stt"> </span><span class="RktSym">xml</span><span class="RktPn">)</span> in the Web Server package would transparently be rewritten to <span class="RktPn">(</span><span class="RktSym"><span class="badlink"><span class="RktValLink">require</span></span></span><span class="stt"> </span><span class="RktPn">(</span><span class="RktSym">real</span><span class="stt"> </span><span class="RktSym">system/web-server/30/.links/xml</span><span class="RktPn">)</span><span class="RktPn">)</span> and rely on the package installation to locate the real module. This includes modules that are part of the package. (N.B. The use of shadow modules specifically does not rely on filesystem links that are confusing and do not work on Windows.)</div></p><p>A well-known package (<span class="stt">"&lt;heap&gt;/SYSTEM/+inf.0/"</span>) would contain a linking directory that serves as the default for packageless modules. This would contain the most recent version of all package modules and prefer the last installed package when two packages have conflicting modules. (This ensures that new unpackaged code by default uses the newer versions of everything.)</p><h4>4.4<tt>&nbsp;</tt><a name="(part._.Discussion)"></a>Discussion</h4><p>This implementation requires very little change from the implementation depending on the level of module protection offered. For example, it appears to me that a standard <span class="RktSym"><span class="badlink"><span class="RktValLink">require</span></span></span> transformer in the <font class="badlink"><span class="RktModLink"><span class="RktSym">racket</span></span></font> language could implement the shadow name mangling and we could use unprovided syntax to protect the underlying real <span class="RktSym"><span class="badlink"><span class="RktValLink">require</span></span></span> form. After that, the various heaps would leverage the existing support for a collection search path. It would require the module level splicing, which is already implemented.</p><p>This implementation plays well with versioning systems because the sources of packages are kept distinct and on a development system (on operating system where it exists) filesystem links could directly tie repositories and installations.</p><p>This implementation provides good support for structuring the core collections as a few packages and ensures that dependencies can&rsquo;t form behind your back (as witness by the many distspec breaks) because all modules see modules from their linking directory rather than the current installation.</p><p>I can&rsquo;t really judge how well this implementation keeps things "in the language". It relies on the state established by the package installer to give meaning to programs and that state is controlled by the package&rsquo;s <span class="stt">"info.rkt"</span> file. However, this might be a realistic sweet-spot given the importance of packages to the program development and deployment environment.</p><p>I think the biggest problem with this implementation is that without a tool it could be confusing to figure out what module file a require statement in a program will resolve to. For example, you have to look in the linking directory (and know to look there), read the fully expanded name, then look at that file. In what I believe to be the common case where there is a single version of every package and no conflicting packages it is very obvious which module will be used, provided you know what package provides a collect. I also think it will be common for packages to provide one collect, with the same name, so hopefully that will be easy to. The situation is the same for packageless files although there is an interesting problem in that the meaning of a program can change because changes in the installation state. Even when that occurs, I think the rule of most new packages is easy to follow.</p><p>Here&rsquo;s a strawman implementation that I think solves that problem: There is a single heap and non-conflicting modules are copied into it, preferring the first installed version. When a new package conflicts with an older one, it is stored in a special name-mangled place. All modules can access everything in the heap, but we perform a simple analysis when compiling to error if other modules (private or non-dependents) are used. When you look at the heap, you cannot tell what module came from what package, but you can easily tell what modules are visible. I think this technique requires more core changes, interacts poorly with versioning systems (because of copying) [think, for example, what our <span class="stt">".gitignore"</span> will contain in the core repository and how we will develop the core and do other work with some packages installed; either the rules will be complicated or we&rsquo;ll need a separation of the source and installation even for the core], depending on how the module protection works it may be easy to accidentally create dependencies, and finally it keeps the meaning of programs totally "in the language" because the state of packages is almost invisible to the runtime. Clearly this is my strawman and I don&rsquo;t think these "costs" are worth it, I&rsquo;d like to know your opinion and proposed implementation.</p><h3>5<tt>&nbsp;</tt><a name="(part._.Glue_between_installation_and_distribution)"></a>Glue between installation and distribution</h3><p>The packaging system only deals with what happens to packages when the get installed while the distribution deals with how they get there. These could be TOTALLY <span style="font-style: italic">separate</span> where packages refer to identifiers with no definite connection to the distribution system OR they could totally <span style="font-style: italic">connected</span> where packages refer to the distribution system explicitly (as in PLaneT.)</p><p>I think there should be a loose connection. This is to facilitate easy installation with downloading a bunch of tarballs and installing them one-by-one (like old Linux distributions) and facilitate easy upgrade by keeping a connection between installed packages and where they came from.</p><p>My explicit proposal: package identifiers are valid URL path elements ending in <span class="stt">".rkb"</span> (Racket Ball, obviously); a package metadate file may contain a dependency specification like <span class="stt">"web-server.rkb/=40"</span> or <span class="stt">"web-server.rkb/40"</span> for exactly 40 and at least 40 respectively; a metadata file <span style="font-style: italic">may</span> also specify a URL ending in such a specification, like <span class="stt">"http://planet.racket-lang.org/pkgs/web-server.rkb/=40"</span> or <span class="stt">"https://secured00d.nsa.gov/sekrut/web-server.rkb/=41"</span>, etc. If such a URL is given, it simply specifies a default place to find the package if it is not already available, but <span style="font-style: italic">any</span> <span class="stt">"web-server.rkb"</span> package will do.</p><p>Every URL-less specification will implicitly reference the centrally hosted PLaneT server.</p><p>A standard file-based protocol will exist between package clients and package servers so no special software with intricate setups will be necessary to start a new package server. This will facilitate private servers and official mirrors.</p><p>Upgrades could be facilitated by checking the version returned by GET-ing <span class="stt">"http://planet.racket-lang.org/pkgs/web-server.rkb"</span> which would REDIRECT to <span class="stt">"http://planet.racket-lang.org/pkgs/web-server.rkb/=<span class="RktVar">newest</span>"</span>. Thus, the URL originally used to install the package (if it was not already located on the filesystem) would be saved to allow update checking, etc.</p><h3>6<tt>&nbsp;</tt><a name="(part._.Package_.Distribution)"></a>Package Distribution</h3><p>The package distribution system (PLaneT) is easy to change and evolve as we go, provided we use a simple URL/HTTP-based mechanism for the clients.</p><p><div class="SIntrapara">I do have a few ideas and basic things to suggest:
</div><div class="SIntrapara"><ul><li><p>Give away accounts as we do now.</p></li><li><p>Allow package submission from the command line by using a HTTP POST with an AUTH header.</p></li><li><p>Provide a simple interface to remove and replace packages (including old versions) arbitrarily.</p></li><li><p>Restrict package names to be prefixed by the user name of the account.</p></li><li><p>Use social tags to filter and categorize packages. No fixed vocabulary.</p></li><li><p>Use Amazon-style review system to establish reputation.</p></li><li><p>Connect to existing <span style="font-style: italic">external</span> bug tracking systems like Launchpad and Github via package metadata.</p></li><li><p>Use reputation to "bless" packages with prefix-less names. For example, jay-mccarthy:mongodb.rkb might become mongodb.rkb after such a blessing.</p></li><li><p>Use Google custom search to package documentation/source.</p></li><li><p>Allow the use of checksums and HTTPS to ensure package contents are as expected.</p></li><li><p>Use moderators to "black ball" malicious packages.</p></li></ul></div></p><p>These ideas give clear priority to leveraging existing tools and limiting the amount of pain and maintenance for PLaneT.</p><p>Some decisions in the packaging layer have big effects on the distribution system, in particular give it the ability to drop certain issues. For example, it is easy to improve a package because you can easily find and change the code on your system then if the maintainer isn&rsquo;t available, you can make a new package with the same module names (so the switch requires no changes in code), then leave a review for the old package directing users to the new one, etc.</p><h3>7<tt>&nbsp;</tt><a name="(part._.Final_.Thoughts)"></a>Final Thoughts</h3><p><div class="SIntrapara">There are a few big open problems in my mind:
</div><div class="SIntrapara"><ul><li><p>Informing new users on installation what packages they might want. We could use the reputation and download counts, but we currently have no final "Get Packages" step in our installers.</p></li><li><p>Interacting with operating system distribution. Hopefully this more file-based infrastructure would ease the process, but I don&rsquo;t really know much about this.</p></li><li><p>Removing the pain of installation by keeping safe ZOs on the server.</p></li><li><p>Once this infrastructure is in place, we should spend a good amount of time breaking the core into packages that are distributed optionally and separately. I believe this requires a good "post install" to keep the batteries included, so to speak.</p></li></ul></div></p><p>Lastly, clearly the existing PLaneT infrastructure needs to stay in place, but I think it should be a vestigial structure that withers away.</p></div></div><div id="contextindicator">&nbsp;</div></body></html>